#summary raphael4gwt getting started guide.
#labels gwt,raphaeljs,raphael,raphael4gwt,raphaelgwt


=What is it?=

A gwt lightweight java API for raphaeljs (http://raphaeljs.com/). It uses gwt overly types for implementing zero overhear java API for raphaeljs.
Based on raphaeljs 2.0. All raphaeljs features supported. Very straightforward java  API to raphael javascript API.



=How to use it?=

1) add the following in your project's gwt.xml file:

{{{
<inherits name="org.sgx.raphael4gwt.Raphael4Gwt" />
}}}

2) add the .jar to your gwt project's classpath

3) you are ready to use it. The following are some GWT Entry point class examples that show different ways of creating a raphael paper

The first is the most easy and that is creating a Raphael paper from "thin air" not asociated with any particular HTML element: 

{{{

package org.sgx.civ.client;

import org.sgx.raphael4gwt.raphael.Attr;
import org.sgx.raphael4gwt.raphael.Paper;
import org.sgx.raphael4gwt.raphael.Raphael;
import org.sgx.raphael4gwt.raphael.Shape;
import org.sgx.raphael4gwt.raphael.event.MouseEventListener;

import com.google.gwt.core.client.EntryPoint;
import com.google.gwt.dom.client.NativeEvent;
import com.google.gwt.user.client.Window;

public class Civ implements EntryPoint {

@Override
public void onModuleLoad() {
	//create a raphael paper at 0,0 screen coords and size 600x600
	Paper paper = Raphael.paper(0, 0, 600, 600);
	
	//draw a red rounded rectangle
	Shape rect1 = paper.rect(20,  10, 220, 250, 14).
			attr(new Attr().fill("red"));
	
	//install a click handler in the rectangle 
	rect1.click(new MouseEventListener() {			
		@Override
		public void notifyMouseEvent(NativeEvent e) {
			Window.alert("ouch at X == "+e.getClientX()); 
		}
	}); 
}

}

}}}

Normally you want to create the raphael paper inside an existing HTML element. For that we pass the element id or the HTML element it self to the Raphael method. In the following example, we create an HTML element and then a Raphael paper inside it. We manipulate the HTML DOM using gwt.dom.client. IMPORTANT: the HTML Element must be attached to the document before creating a Raphael paper on it: 

{{{

package org.sgx.raphael4gwt.test;

import org.sgx.raphael4gwt.raphael.Circle;
import org.sgx.raphael4gwt.raphael.Paper;
import org.sgx.raphael4gwt.raphael.Raphael;

import com.google.gwt.core.client.EntryPoint;
import com.google.gwt.dom.client.DivElement;
import com.google.gwt.dom.client.Document;

/**
 * a gwt entry points that shows a very simple use case using 
 * gwt.client.dom for creating an element in the body and attach 
 * a raphael paper to it. Has nothing to do with GWT widgets. 
 * @author sg
 */
public class Raphael4GwtTestAloneNoWidget implements EntryPoint {
	@Override
	public void onModuleLoad() {
		DivElement el1 = Document.get().createDivElement();
		
		//ensure the element is attach to document before crating raphael paper
		Document.get().getBody().appendChild(el1);
		
		//create the raphael paper using the simplepanel
		Paper paper = Raphael.paper(el1, 1500, 1500);
		
		//draw something
		Circle circle1 = paper.circle(150, 150, 40);
		circle1.setAttribute("fill", "red");	
	}	
}


}}}


the second way is similar to the first, but using a GWT SimplePanel widget, and creating the raphael paper inside it. 
{{{
package org.sgx.raphael4gwt.test;

import org.sgx.raphael4gwt.raphael.Circle;
import org.sgx.raphael4gwt.raphael.Paper;
import org.sgx.raphael4gwt.raphael.Raphael;

import com.google.gwt.core.client.EntryPoint;
import com.google.gwt.user.client.ui.RootPanel;
import com.google.gwt.user.client.ui.SimplePanel;

/**
 * a gwt entry points that shows a very simple use case.
 * @author sg
 */
public class Raphael4GwtTestAloneSimple implements EntryPoint {
	@Override
	public void onModuleLoad() {
		//we will use a simple panel in which to put our aphael paper:
		SimplePanel paperPanel = new SimplePanel();
		
		//ensure the element is attach to document before crating raphael paper
		RootPanel.get().add(paperPanel); 
			
		//create the raphael paper using the simplepanel
		Paper paper = Raphael.paper(paperPanel.getElement(), 1500, 1500);
		
		//draw something
		Circle circle1 = paper.circle(150, 150, 40);
		circle1.setAttribute("fill", "red");	
	}	
}
}}}

or a gwt entry point class showing a raphael paper using PaperWidget, a rudimentary GWT widget that shows a raphael Paper in which you can draw. It is very easy to use with GWT widgets: 

{{{

package org.sgx.raphael4gwt.test;

import org.sgx.raphael4gwt.raphael.Circle;
import org.sgx.raphael4gwt.raphael.Paper;
import org.sgx.raphael4gwt.raphael.PaperWidget;
import org.sgx.raphael4gwt.raphael.event.PaperListener;

import com.google.gwt.core.client.EntryPoint;
import com.google.gwt.user.client.ui.Button;
import com.google.gwt.user.client.ui.FlowPanel;
import com.google.gwt.user.client.ui.RootPanel;
import com.google.gwt.user.client.ui.VerticalPanel;

/**
 * a gwt entry points that use PaperWidget for showing a 
 * raphael paper in it, with other gwt widgets.
 * @author sg
 */
public class Raphael4GwtTestAlone implements EntryPoint, PaperListener {

	String attr1 = "world";
	private PaperWidget paper;
	
	@Override
	public void onModuleLoad() {
		
		VerticalPanel vp = new VerticalPanel();		
		
		//some gwt buttons
		FlowPanel toolbar = new FlowPanel();
		toolbar.add(new Button("action1"));
		toolbar.add(new Button("action2"));
		vp.add(toolbar);
		
		paper = new PaperWidget(600, 600, this);
		paper.setSize("100%", "100%");
		vp.add(paper);
		
		/* note: the followind attach all gwt widgets 
		 * elements to the DOM document. raphaeljs requires to create a paper 
		 * in a html element that is attached to document, but because WidgetPanel
		 * do creates the paper asynchronously and only at Widget:onload()
		 * we can safely create the WidgetPanel before attach parent to document.
		 */
		RootPanel.get().add(vp); 
	}
	
	@Override
	public void paperLoaded(Paper paper) {
		//raphael's paper is ready to draw in:
		final Circle circle1 = paper.circle(150, 150, 40);
		circle1.setAttribute("fill", "red");		
	}

}


}}}



=Dynamic JavaScript loading =

when inheriting org.sgx.raphael4gwt.Raphael4Gwt GWT module your GWT application will load all the required JavaScript code. For org.sgx.raphael4gwt.Raphael4Gwt this is about 140 kb and for org.sgx.raphael4gwt.GRaphael4Gwt are 140 + 40 = 180 kb in total.

This is not good when trying to optimize initial web page startup time, and fortunately raphael4gwt comes with Modules and utilities that will let you load these necessary javascript code synamically only when needed. You must: 

  # inherit org.sgx.raphael4gwt.GRaphael4GwtNoScript GWT module instead of org.sgx.raphael4gwt.GRaphael4Gwt. GRaphael4GwtNoScript will not load any extra javascript at startup.  

  # use RaphaelLoader utility class for loading raphael or graphael javascript code dynamically only when you need the tool. The following EntryPoint class shows howto. When a button that when clicked will load the required Js files and show a Graphael Pie chart. 

Open it using a network traffic tool like firebug and see how javascript is loading. 

Initially only 18kb of js is loaded for displaying the the document and after the button is clicked two files of aprox 195kb (total) are loaded and then a chart is showed. these 195kbs are the javascript files corresponding to raphael and graphael code that are only loaded when required for showing a chart: 

{{{
import org.sgx.raphael4gwt.graphael.GPaper;
import org.sgx.raphael4gwt.graphael.GRaphaelLoader;
import org.sgx.raphael4gwt.graphael.pie.PieOpts;
import org.sgx.raphael4gwt.raphael.Raphael;
import org.sgx.raphael4gwt.raphael.RaphaelLoader.Listener;

import com.google.gwt.core.client.EntryPoint;
import com.google.gwt.event.dom.client.ClickEvent;
import com.google.gwt.event.dom.client.ClickHandler;
import com.google.gwt.user.client.Window;
import com.google.gwt.user.client.ui.Button;
import com.google.gwt.user.client.ui.RootPanel;

public class Raphael4gwtNoScriptTestEP implements EntryPoint {

	@Override
	public void onModuleLoad() {
		RootPanel.get().add(new Button("load graphael example", new ClickHandler() {			
			@Override
			public void onClick(ClickEvent event) {
				GRaphaelLoader.loadGRaphael(new Listener() {			
					@Override
					public void loaded(Exception error) {
						if(error == null) {
							doGraphaelExample(); 
						}
						else {
							Window.alert("ERROR loading graphael : "+error);
							error.printStackTrace(); 
						}
					}
				}); 
			}
		})); 
		
	}

	private void doGraphaelExample() {
        	GPaper paper = Raphael.paper(0,0,600,600).cast();
        	PieOpts opts = PieOpts.create(); 
        	paper.piechart(200f, 200, 100, new double[]{10, 40, 70, 90}, opts);
	}

}
}}}



= Generate the .jar using ant =

This section explains how to build raphel4gwt.jar file from SVN. You will need the following software : Java, GWT SDK, subversion (svn) and ant. In a *nix shell the steps are the following: 


{{{
#download the SVG repository
svn checkout http://raphael4gwt.googlecode.com/svn/trunk/raphael4gwt raphael4gwt-read-only

cd raphael4gwt-read-only

#edit gwt.sdk property in build.properties according to your system (points to GWT SDK folder). In this example use the cat command for ilustration but you can use your favourite text editor. 
cat > build.properties
gwt.sdk=/home/sebastian/programas/gwt-2.4.0
raphael4gwt.version=0.37
Ctrl-D

ant jar
}}}

If everything was fine, you should have raphael4gwt jar file at dist/ folder. 

Note, if in the last example, you make `ant compile` you will compile all the raphael4gwt exmpales, so after the command finish you could open `war/index.html` in your browser for running the main raphael4gwt example gallery and `war/graphaelExamples.html` for graphael example gallery. 


= Maven = 

This project has a maven project definition. You can for example, download the sources and install the project on your maven system: 

{{{

svn checkout http://raphael4gwt.googlecode.com/svn/trunk/raphael4gwt raphael4gwt-read-only
cd aphael4gwt-read-only
mvn install

}}}

Once you have installed it on your system like before, then you can include it as a maven dependency in you Gwt projects. This is the relevant information for that. Sorry, this project is not currently on maven central or any other repository.

{{{

<groupId>org.sgx</groupId>
<artifactId>raphael4gwt</artifactId>
<version>1.0</version>

}}}



=Project objectives=

the objective is to provide the most direct java API to raphaeljs javascript API.
Nevertheless, when javascript overloading methods is overused in javascript, 
some API methods are renamed from original. For example, Element.attr function
is Divided into Shap.setAttribute(s) and getAttribute(s). 
Also artificial classes like MouseEventListener and Attrs, but always performing critical operations with zero overhead. 

Also this project author is writing a [http://cancerbero.vacau.com/raphaeltut/ Raphaeljs tutorial] documenting all raphaeljs features not obvious for users new to SVG and vector drawing. A lot of raphael extensions are collected and documented there, and many of this exatensions, some authored by Sebastián Gurin, are included on raphael4gwt. 



=raphael4gwt vs. raphaelgwt - why another raphael gwt porting?=

The project raphaelgwt, is a known raphael java API for GWT. It is well integrated with GWT widgets, for example
each raphael shap like circles, rectangles, etc are gwt widgets. raphaelgwt uses gwt event system for manage raphael shapes events and not raphaeljs native event system.

This can be good because it allows that wraps the overlay with a more Java-friendly API that will operate side-by-side with other GWT Widgets. 

raphaelgwt also has the class RaphaelJS for doing raphael stuff natively. In gwt4raphael's author opinion, gwtraphael's RaphaelJS class 

*  do not cover the 100% raphaeljs native stuff, for example there is no java api for raphaeljs native event (because events are managed only at GWT widget level).

* is not a rich java api for raphael objects, It try to cover all shapes api with a single class (Raphaeljs)

So in conclusion (IMHO) raphaelgwt is not a good native raphaeljs java API for GWT. It focus on integration with GWT widgets but not in a good & updated raphaeljs java API.

raphael4gwt on the other hand focus on a complete and direct java API for raphaeljs. This means that in  your GWT applications you use raphael4gwt the as you would use raphaeljs natively. You create a raphael paper in some existing dom element, draw circles, text paths in that paper, set some attributes, and possible register some events handlers, perform animations, etc. 

in raphael4gwt there is minimal tools for integrating with GWT widgets. There exists a simple PaperWidget, a GWT widget with a raphael paper inside. But raphaels circles, rects, paths, etc won't be gwt Widgets as oposition to raphaelgwt but native (overlay type) objects for no object wrapping overhead.

in raphael4gwt, raphael shapes shapes events are not related at all with gwt widgets events. The only thing it is used from gwt api is gwt.client.dom classes for referencing html dom objects in the API when neccesary.

Another big difference is that currently raphaelgwt is based on raphaeljs 1.x, while raphael4gwt is based on raphael 2.x.

Also I already have experience developing a raphaeljs java API, but for java2script, a framework similar to GWT. 
The project http://yui4java.sourceforge.net/ contains some java APIs for java2script of known javascript toolkits like yui 2 and 3, soundmanager, and raphaeljs.
See for example a demonstration of my raphael java API for java2script (using also yui java API, check suorce code in the demo itself): 
http://yui4java.sourceforge.net/yui/org.sgx.j2s.raphael.test.demo.Main.html

Now I'm learning best practices for porting existing javascript toolkits to GWT instead java2script. 

With this in mind, I developed raphael4gwt, enjoy it. Perhaps one day raphalegwt can adopt it for the 
lower layers, or vice versa, migrate raphael4gwt code to raphaelgwt for getting the both things, a good 
raphaeljs 2.0 java API (based on gwt overlay types) and good integration between raphael Shapes and GWT widgets. 