#summary raphael4gwt getting started guide.
#labels gwt,raphaeljs,raphael,raphael4gwt,raphaelgwt


=What is it?=

A gwt lightweight java API for raphaeljs (http://raphaeljs.com/). It uses gwt overly types for implementing zero overhear java API for raphaeljs.
Based on raphaeljs 2.0. All raphaeljs features supported. Very straightforward java  API to raphael javascript API.


=How to use it?=

1) add the following in your project's gwt.xml file:

{{{
<inherits name="org.sgx.raphael4gwt.Raphael4Gwt" />
}}}

2) add the .jar to your gwt project's classpath

3) you are ready to use it, from your entry point class:

{{{
Paper paper = Raphael.paper(0, 0, 500, 500);
Circle circle1 = paper.circle(250,250, 100);
circle1.setAttribute("fill", "red");
circle1.mouseDown(new MouseEventListener() {			
	@Override
	public void notifyMouseEvent(NativeEvent e) {
		Window.alert("mouse clicked the circle at: "+e.getClientX()+", "+e.getClientY());
	}
});
}}}

or a gwt entry point class showing a raphael paper using WidgetPanel, a rudimentary GWT widget that shows a raphael Paper in which you can draw:

{{{

package org.sgx.raphael4gwt.test;

import org.sgx.raphael4gwt.raphael.Circle;
import org.sgx.raphael4gwt.raphael.Paper;
import org.sgx.raphael4gwt.raphael.PaperWidget;
import org.sgx.raphael4gwt.raphael.event.PaperListener;

import com.google.gwt.core.client.EntryPoint;
import com.google.gwt.user.client.ui.Button;
import com.google.gwt.user.client.ui.FlowPanel;
import com.google.gwt.user.client.ui.RootPanel;
import com.google.gwt.user.client.ui.VerticalPanel;

/**
 * a gwt entry points that use PaperWidget for showing a 
 * raphael paper in it, with other gwt widgets.
 * @author sg
 */
public class Raphael4GwtTestAlone implements EntryPoint, PaperListener {

	String attr1 = "world";
	private PaperWidget paper;
	
	@Override
	public void onModuleLoad() {
		
		VerticalPanel vp = new VerticalPanel();		
		
		//some gwt buttons
		FlowPanel toolbar = new FlowPanel();
		toolbar.add(new Button("action1"));
		toolbar.add(new Button("action2"));
		vp.add(toolbar);
		
		paper = new PaperWidget(600, 600, this);
		paper.setSize("100%", "100%");
		vp.add(paper);
		
		/* note: the followind attach all gwt widgets 
		 * elements to the DOM document. raphaeljs requires to create a paper 
		 * in a html element that is attached to document, but because WidgetPanel
		 * do creates the paper asynchronously and only at Widget:onload()
		 * we can safely create the WidgetPanel before attach parent to document.
		 */
		RootPanel.get().add(vp); 
	}
	
	@Override
	public void paperLoaded(Paper paper) {
		//raphael's paper is ready to draw in:
		final Circle circle1 = paper.circle(150, 150, 40);
		circle1.setAttribute("fill", "red");		
	}

}


}}}

the objective is to provide the most direct java API to raphaeljs javascript API.
Nevertheless, when javascript overloading methods is overused in javascript, 
some API methods are renamed from original. For example, Element.attr function
is Divided into Shap.setAttribute(s) and getAttribute(s). 
Also artificial classes like MouseEventListener and Attrs, but always performing critical 
operations with zero overhead.



=why another raphael gwt porting?=

The project raphaelgwt, is a known raphael java API for GWT. It is well integrated with GWT widgets, for example
each raphael shap like circles, rectangles, etc are gwt widgets. raphaelgwt uses gwt event system for manage raphael shapes events and not raphaeljs native event system.

This can be good because it allows that wraps the overlay with a more Java-friendly API that will operate side-by-side with other GWT Widgets. 

raphaelgwt also has the class RaphaelJS for doing raphael stuff natively. In gwt4raphael's author opinion, gwtraphael's RaphaelJS class 

*  do not cover the 100% raphaeljs native stuff, for example there is no java api for raphaeljs native event (because events are managed only at GWT widget level).

* is not a rich java api for raphael objects, It try to cover all shapes api with a single class (Raphaeljs)

so in conclusion raphaelgwt is not a good native raphaeljs java API for gwt.

raphael4gwt on the other focus on a good native java api for raphaeljs. Basically the main objective is to provide a 100%
java API implementation of raphael javascript api. Basically this means that, int your gwt applications you have to use raphael4gwt the as you 
would use raphaeljs natively. You create a raphael paper in some existing dom element, draw circles, text paths in that paper and 
posible register some events handlers. 

in raphael4gwt There exists a simple PaperWidget, a gwt widget with a raphael paper inside. But raphaels circles, rects, paths, etc won't be gwt Widgets as oposition to raphaelgwt but native (overlay type) objects for no object wrapping overhead.

in raphael4gwt, raphael shapes shapes events are not related at all with gwt widgets events. The only thing it is used from gwt api is gwt.client.dom classes for referencing html dom objects.

Currently raphaelgwt is based on raphaeljs 1.x, while raphael4gwt is based on raphael 2.x.

Also I already have experience developing a raphaeljs java API, but for java2script, a framework similar to GWT. 
The project http://yui4java.sourceforge.net/ contains some java APIs for java2script of known javascript toolkits like yui 2 and 3, soundmanager, and raphaeljs.
See for example a demonstration of my raphael java API for java2script (using also yui java API, check suorce code in the demo itself): 
http://yui4java.sourceforge.net/yui/org.sgx.j2s.raphael.test.demo.Main.html

Now I'm learning best practices for porting existing javascript toolkits to GWT instead java2script. 

With this in mind, I developed raphael4gwt, enjoy it. Perhaps one day raphalegwt can adopt it for the 
lower layers, or vice versa, migrate raphael4gwt code to raphaelgwt for getting the both things, a good 
raphaeljs 2.0 java API (based on gwt overlay types) and good integration between raphael Shapes and GWT widgets. 